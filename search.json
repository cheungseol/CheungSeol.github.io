[{"title":"test","url":"http://yoursite.com/2016/04/20/test/","content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"string\">\"x.h\"</span></span></span><br><span class=\"line\">main()&#123;</span><br><span class=\"line\">\tprint(<span class=\"string\">\"hello world!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>(<span class=\"params\">c,p</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> p)&#123;</span><br><span class=\"line\">\t\tc[i] = p[i];\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"清除浮动小结","url":"http://yoursite.com/2016/04/19/清除浮动小结/","content":"<p>浮动是布局的时候常用的方法，所谓“浮动”嘛，字面意思就是能向上浮就尽量向上排列，由于浮动元素脱离文档流，完全不在页面中占据位置了，所以就导致位于浮动元素后面的元素都会跟着向上排列。</p>\n<p>不想让位于浮动元素后面的元素跟着乱动，解决方法基本无外乎以下几种。</p>\n<p>举个栗子</p>\n<pre><code>&lt;section&gt;\n    &lt;img src=&quot;&quot; alt=&quot;&quot;&gt;\n    &lt;p&gt;I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.&lt;/p&gt;\n&lt;/section&gt;\n&lt;footer&gt;I don&apos;t want to change my position.I don&apos;t want to change my position.I don&apos;t want to change my position.I don&apos;t want to change my position.&lt;/footer&gt;\n\n\n&lt;style&gt;\n    section{\n        border: 1px solid red;\n        margin: 0 0 10px 0;\n    }\n    img{\n        float: left;\n    }\n    footer{\n        border: 1px solid yellow;\n    }\n&lt;/style&gt;\n</code></pre><h2 id=\"方法一-：同时浮动父元素\"><a href=\"#方法一-：同时浮动父元素\" class=\"headerlink\" title=\"方法一 ：同时浮动父元素\"></a>方法一 ：同时浮动父元素</h2><pre><code>&lt;style&gt;\n    section{\n        border: 1px solid red;\n        float: left;   // 浮动后会紧包住子元素，无论子元素是否浮动\n        width: 100%;   // 由于会紧包住子元素，需要设置与浏览器同宽\n    }\n    img{\n        float: left;\n    }\n    footer{\n        border: 1px solid yellow;\n        clear: left;   // 强制footer元素乖乖待在section下面\n    }\n&lt;/style&gt;\n</code></pre><h2 id=\"方法二：-父元素-overflow-hidden\"><a href=\"#方法二：-父元素-overflow-hidden\" class=\"headerlink\" title=\"方法二： 父元素 overflow:hidden\"></a>方法二： 父元素 overflow:hidden</h2><pre><code>&lt;style&gt;\n    section{\n        border: 1px solid red;\n        overflow: hidden;\n        margin: 0 0 10px 0;\n    }\n    img{\n        float: left;\n    }\n    footer{\n        border: 1px solid yellow;\n    }\n&lt;/style&gt;\n</code></pre><p>##方法三： 添加清除浮动元素<br>在浮动元素后面添加一个清除浮动元素。因为父元素会包主清除浮动元素，所以也一并包裹住了清除元素之前的浮动元素。</p>\n<pre><code>&lt;section&gt;\n    &lt;img src=&quot;&quot; alt=&quot;&quot;&gt;\n    &lt;p&gt;I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.&lt;/p&gt;\n    &lt;div class=&quot;clear_me&quot;&gt;&lt;/div&gt;\n&lt;/section&gt;\n&lt;footer&gt;I don&apos;t want to change my position.I don&apos;t want to change my position.I don&apos;t want to change my position.I don&apos;t want to change my position.&lt;/footer&gt;\n\n&lt;style&gt;\n    section{\n        border: 1px solid red;\n        margin: 0 0 10px 0;\n    }\n    img{\n        float: left;\n    }\n    .clear_me{\n        clear: left;\n    }\n    footer{\n        border: 1px solid yellow;\n    }\n&lt;/style&gt;\n</code></pre><p>##方法四： 添加清除浮动伪元素</p>\n<pre><code>&lt;section class=&quot;clearfic&quot;&gt;\n    &lt;img src=&quot;&quot; alt=&quot;&quot;&gt;\n    &lt;p&gt;I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.I am a text.&lt;/p&gt;\n&lt;/section&gt;\n&lt;footer&gt;I don&apos;t want to change my position.I don&apos;t want to change my position.I don&apos;t want to change my position.I don&apos;t want to change my position.&lt;/footer&gt;\n\n&lt;style&gt;\n    section{\n        border: 1px solid red;\n        margin: 0 0 10px 0;\n    }\n    img{\n        float: left;\n    }\n    .clearfix{\n        content: &quot;.&quot;;\n        display: block;\n        height: 0;\n        visibility: hidden;\n        clear: both;\n    }\n    footer{\n        border: 1px solid yellow;\n    }\n&lt;/style&gt;\n</code></pre><p>对于没有父元素的情形，可以给浮动元素后的元素添加.clearfix样式。</p>\n"},{"title":"post","url":"http://yoursite.com/2016/04/19/ES 5、ES 6变量和函数声明以及作用域总结/","content":"<h1 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h1><p>JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这段代码运行的结果是：undefined<br>第一，function作用域里的变量v遮盖了上层作用域变量v。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码做少些变动，输出结果为”hello”,说明ES 5是没有块级作用域的。函数是ES 5中唯一拥有自身作用域的结构。</p>\n<p>第二，在function作用域内，变量v的声明被提升了。所以最初的代码相当于：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> v; <span class=\"comment\">//declaration hoisting</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">  v = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"string\">\"2\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = <span class=\"string\">\"3\"</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>变量a,f,b,c的声明会被提升到函数作用域的最前面，类似如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a,f,b,c;</span><br><span class=\"line\">  a = <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">  f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  b = <span class=\"string\">\"2\"</span>;</span><br><span class=\"line\">  c = <span class=\"string\">\"3\"</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>下面的代码中函数声明f2被提升，所以在前面调用f2是没问题的。虽然变量f1也被提升，但f1提升后的值为undefined,其真正的初始值是在执行到函数表达式处被赋予的。所以只有声明是被提升的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//var f1,function f2()&#123;&#125;; //hoisting,被隐式提升的声明</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  f1(); <span class=\"comment\">//ReferenceError: f1 is not defined</span></span><br><span class=\"line\">  f2();</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">var</span> f1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h1 id=\"ES5-有var和没var声明\"><a href=\"#ES5-有var和没var声明\" class=\"headerlink\" title=\"ES5 有var和没var声明\"></a>ES5 有var和没var声明</h1><p>ES5中只有<strong>全局作用域</strong>和<strong>函数作用域</strong>，我们依次分析。</p>\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i=<span class=\"number\">100</span>;  <span class=\"comment\">//显示申明</span></span><br><span class=\"line\"></span><br><span class=\"line\">i=<span class=\"number\">100</span>;  <span class=\"comment\">//隐式申明</span></span><br></pre></td></tr></table></figure>\n<p>在函数内部，有var和没var声明的变量是不一样的。在函数中使用var关键字进行显式申明的变量是做为局部变量，而没有用var关键字，使用直接赋值方式声明的是全局变量，所以可以借此向外暴露接口。</p>\n<p>JavaScript中变量声明有var和没var的区别，所以ES5中经常见到避免全局变量污染的方法是匿名立即执行函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\"> <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"全局作用域\"><a href=\"#全局作用域\" class=\"headerlink\" title=\"全局作用域\"></a>全局作用域</h2><p>在全局作用域内声明变量时，有var 和没var看起来都一样，声明的全局变量，就是window的属性。但其实还是有差别的，我们用delete删除属性来验证下，配置性为false的属性无法删除。也就是通过变量var声明全局对象的属性无法删除，我们还会发现和函数声明创建的全局对象属性也无法删除。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fff = <span class=\"number\">2</span>; </span><br><span class=\"line\"><span class=\"built_in\">window</span>.ffa = <span class=\"number\">3</span>; </span><br><span class=\"line\">ffb = <span class=\"number\">4</span>; </span><br><span class=\"line\"><span class=\"keyword\">this</span>.ffc = <span class=\"number\">4</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> ffftx = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(<span class=\"built_in\">window</span>, <span class=\"string\">'fff'</span>); <span class=\"comment\">//configurable:false,enumerable:true,value:2,writable:true </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ffatx = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(<span class=\"built_in\">window</span>, <span class=\"string\">'ffa'</span>); <span class=\"comment\">//configurable:true,enumerable:true,value:2,writable:true </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ffbtx = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(<span class=\"built_in\">window</span>, <span class=\"string\">'ffb'</span>); <span class=\"comment\">//configurable:true,enumerable:true,value:2,writable:true </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ffctx = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(<span class=\"built_in\">window</span>, <span class=\"string\">'ffc'</span>); <span class=\"comment\">//configurable:true,enumerable:true,value:2,writable:true</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> fff; <span class=\"comment\">// 无法删除 </span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> ffa; <span class=\"comment\">// 可删除 </span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> ffb; <span class=\"comment\">// 可删除 </span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> ffc; <span class=\"comment\">// 可删除</span></span><br></pre></td></tr></table></figure>\n<p>使用var声明变量，是在当前域中声明变量. 如果在方法中声明，则为局部变量；如果是在全局域中声明，则为全局变量。而num = 1，事实上是对属性赋值操作。首先，它会尝试在当前作用域链（如在方法中声明，则当前作用域链代表全局作用域和方法局部作用域etc。。。）中解析 num； 如果在任何当前作用域链中找到num，则会执行对num属性赋值； 如果没有找到num，它才会在全局对象（即当前作用域链的最顶层对象，如window对象）中创造num属性并赋值。</p>\n<p><strong>注意！</strong>没有用var关键字，本质上并不是声明了一个全局变量，而是创建了一个全局对象的属性。</p>\n<h1 id=\"函数定义两种方式的区别\"><a href=\"#函数定义两种方式的区别\" class=\"headerlink\" title=\"函数定义两种方式的区别\"></a>函数定义两种方式的区别</h1><p>函数定义有两种方式，一种是函数定义表达式，一种是函数声明语句。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数定义表达式 </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fns = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\"><span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;； </span><br><span class=\"line\"><span class=\"comment\">// 函数声明语句 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fns</span>(<span class=\"params\"></span>)</span>&#123; </span><br><span class=\"line\"><span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于声明是会被提前的，所以函数声明语句“被提前”到外部脚本或外部函数作用域的顶部，所以以这种方式声明的函数，可以被再它定义之前出现的代码所调用。而函数定义表达式中，变量的声明被提前了，但是给变量的赋值是不会提前的，所以，以表达式方式定义的函数在函数定义之前无法调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\ttesta();<span class=\"comment\">// 打印出testa </span></span><br><span class=\"line\">\ttestb();<span class=\"comment\">// 报错：提示undefined is not a function </span></span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(testc); <span class=\"comment\">//undefined,如果移到上面就可以了 </span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testa</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"testa\"</span>); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">var</span> testb = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"tesb\"</span>); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">var</span> testc = <span class=\"string\">\"testc\"</span>; </span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h1 id=\"ES-6对块级作用域的支持\"><a href=\"#ES-6对块级作用域的支持\" class=\"headerlink\" title=\"ES 6对块级作用域的支持\"></a>ES 6对块级作用域的支持</h1><h2 id=\"ES-5没有块级作用域\"><a href=\"#ES-5没有块级作用域\" class=\"headerlink\" title=\"ES 5没有块级作用域\"></a>ES 5没有块级作用域</h2><p>经常容易遇到两类问题。</p>\n<ul>\n<li>内层变量可能会覆盖外层变量。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"string\">\"hello world\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>\n<ul>\n<li>用来计数的循环变量泄露为全局变量。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ES-6对块级作用域的支持-1\"><a href=\"#ES-6对块级作用域的支持-1\" class=\"headerlink\" title=\"ES 6对块级作用域的支持\"></a>ES 6对块级作用域的支持</h2><p>上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6允许块级作用域的任意嵌套。外层作用域无法读取内层作用域的变量。内层作用域可以定义外层作用域的同名变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;&#123;&#123;&#123;</span><br><span class=\"line\">  &#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>&#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(insane); <span class=\"comment\">// 报错</span></span><br><span class=\"line\">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;&#123;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">  &#123;<span class=\"keyword\">let</span> insane = <span class=\"string\">'Hello World'</span>;&#125;</span><br><span class=\"line\">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>\n<p>ES6也规定，函数本身的作用域，在其所在的块级作用域之内。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am outside!'</span>); &#125;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 重复声明一次函数f</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am inside!'</span>); &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  f();   <span class=\"comment\">//  *</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>上面代码在ES5中运行，会得到“I am inside!”，但是在ES6中运行，会得到“I am outside!”。这是因为ES5存在函数提升，不管会不会进入 if代码块，函数声明都会提升到当前作用域的顶部，得到执行；而ES6支持块级作用域，不管会不会进入if代码块作用域，其内部声明的函数皆不会影响到作用域的外部，即*所在行的函数不会受if代码块内部的影响。</p>\n<p>块级作用域外部，无法调用块级作用域内部定义的函数。如果确实需要调用，就要像下面这样处理。值得注意的是，有的浏览器可能并不认为{ }形成了一个块级作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">'secret'</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n<p>如果确实需要调用，就要像下面这样处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> f;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">'secret'</span>;</span><br><span class=\"line\">  f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() <span class=\"comment\">// \"secret\"</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"var和let、const的区别\"><a href=\"#var和let、const的区别\" class=\"headerlink\" title=\"var和let、const的区别\"></a>var和let、const的区别</h1><h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><ul>\n<li>let和const命令所声明的变量，只在let命令所在的代码块内有效。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   \t&#123;</span><br><span class=\"line\">   \t  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">   \t  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">   \t&#125;</span><br><span class=\"line\">   \t</span><br><span class=\"line\">   \ta <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">   \tb <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>循环的计数器，就很合适使用<span class=\"keyword\">let</span>命令。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;&#125;</span><br><span class=\"line\">   \t</span><br><span class=\"line\">   \t<span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">   \t<span class=\"comment\">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>\n<p>用var声明的变量i，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。</p>\n<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p>用let声明的变量i，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"const命令声明的变量不允许修改\"><a href=\"#const命令声明的变量不允许修改\" class=\"headerlink\" title=\"const命令声明的变量不允许修改\"></a>const命令声明的变量不允许修改</h2><p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;&#125;;</span><br><span class=\"line\">foo.prop = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.prop</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = &#123;&#125; <span class=\"comment\">// TypeError: \"foo\" is read-only</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">\"Hello\"</span>); <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>;<span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">\"Dave\"</span>];<span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n<p>如果真的想将对象冻结，应该使用Object.freeze方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 常规模式时，下面一行不起作用；</span></span><br><span class=\"line\">    <span class=\"comment\">// 严格模式时，该行会报错</span></span><br><span class=\"line\">    foo.prop = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>\n<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> constantize = (obj) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.freeze(obj);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach( (key, value) =&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">'object'</span> ) &#123;</span><br><span class=\"line\">   constantize( obj[key] );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量提升-1\"><a href=\"#变量提升-1\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><p>let和const没有“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"重复声明\"><a href=\"#重复声明\" class=\"headerlink\" title=\"重复声明\"></a>重复声明</h2><p>使用var语句重复声明语句是合法且无害的。如果重复声明且带有赋值，那么就和一般的赋值语句没差别。如果尝试读取没有声明过的变量，Js会报错。 </p>\n<p>但是ES 6中新增的let、constlet不允许在相同作用域内，重复声明同一个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此，不能在函数内部重新声明参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 报错</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arg; <span class=\"comment\">// 不报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Hello World","url":"http://yoursite.com/2016/04/18/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n"}]